<!DOCTYPE HTML>
<html>

<head>
	<title>TradingView - Multi-Currency Harmonic Pattern Scanner</title>

	<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">

	<script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
	<script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>

	<style>
		body {
			margin: 0px;
			font-family: Arial, sans-serif;
			background: #131722;
			color: #d1d4dc;
		}

		.controls {
			position: fixed;
			top: 10px;
			right: 10px;
			background: rgba(19, 23, 34, 0.95);
			border: 1px solid #2a2e39;
			padding: 15px;
			border-radius: 8px;
			z-index: 1000;
			max-width: 380px;
			max-height: 90vh;
			overflow-y: auto;
		}

		.symbol-section {
			margin-bottom: 15px;
			padding: 10px;
			background: #1a1e27;
			border-radius: 6px;
			border: 1px solid #2a2e39;
		}

		.symbol-selector {
			width: 100%;
			padding: 8px;
			background: #2a2e39;
			color: white;
			border: 1px solid #434651;
			border-radius: 4px;
			margin-bottom: 10px;
		}

		.quick-symbols {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			margin-bottom: 10px;
		}

		.symbol-btn {
			padding: 5px 8px;
			background: #2a2e39;
			color: white;
			border: 1px solid #434651;
			border-radius: 3px;
			cursor: pointer;
			font-size: 11px;
		}

		.symbol-btn:hover {
			background: #363a45;
		}

		.symbol-btn.active {
			background: #1976d2;
		}

		.pattern-button {
			display: block;
			width: 100%;
			margin: 5px 0;
			padding: 12px;
			background: #2a2e39;
			color: white;
			border: 1px solid #434651;
			border-radius: 4px;
			cursor: pointer;
			font-size: 13px;
			position: relative;
		}

		.pattern-button:hover {
			background: #363a45;
		}

		.pattern-button.active {
			background: #1976d2;
		}

		.pattern-button.scanning {
			background: #ff9800;
			animation: pulse 1.5s infinite;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.7;
			}
		}

		.pattern-count {
			position: absolute;
			right: 10px;
			top: 50%;
			transform: translateY(-50%);
			background: #4CAF50;
			color: white;
			padding: 2px 6px;
			border-radius: 10px;
			font-size: 10px;
			display: none;
		}

		.clear-button {
			background: #f44336 !important;
		}

		.status {
			margin: 10px 0;
			padding: 10px;
			background: #2a2e39;
			border-radius: 4px;
			font-size: 12px;
			border-left: 3px solid #4CAF50;
		}

		.chart-info {
			margin: 10px 0;
			padding: 8px;
			background: #1a1e27;
			border-radius: 4px;
			font-size: 11px;
			color: #9598a1;
		}

		.pattern-results {
			margin-top: 15px;
			max-height: 200px;
			overflow-y: auto;
		}

		.pattern-item {
			background: #2a2e39;
			border: 1px solid #434651;
			border-radius: 4px;
			padding: 8px;
			margin: 5px 0;
			font-size: 11px;
		}

		.pattern-name {
			font-weight: bold;
			color: #4CAF50;
			margin-bottom: 3px;
		}

		.pattern-details {
			color: #9598a1;
			line-height: 1.3;
		}

		.timeframe-selector {
			width: 100%;
			padding: 6px;
			background: #2a2e39;
			color: white;
			border: 1px solid #434651;
			border-radius: 4px;
			margin-bottom: 10px;
			font-size: 12px;
		}
	</style>

	<script type="text/javascript">
		let widget;
		let shapeIds = [];
		let currentSymbol = 'EURUSD';
		let currentTimeframe = '1H';
		let isScanning = false;
		let chartDataStore = {};

		// Popular trading instruments
		const tradingInstruments = {
			'Forex': [
				'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
				'EURJPY', 'GBPJPY', 'EURGBP', 'AUDJPY', 'EURAUD', 'EURCHF', 'AUDCAD'
			],
			'Crypto': [
				'BTCUSD', 'ETHUSD', 'ADAUSD', 'SOLUSD', 'DOTUSD', 'LINKUSD', 'AVAXUSD',
				'MATICUSD', 'ATOMUSD', 'ALGOUSD', 'XRPUSD', 'LTCUSD', 'BCHUSD'
			],
			'Stocks': [
				'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NFLX', 'NVDA',
				'JPM', 'BAC', 'XOM', 'JNJ', 'PG', 'KO', 'DIS', 'IBM'
			],
			'Indices': [
				'SPX', 'NAS100', 'DJI', 'FTSE', 'DAX', 'CAC40', 'NIKKEI', 'HSI',
				'RUSSELL2000', 'VIX', 'GOLD', 'SILVER', 'OIL', 'NATGAS'
			]
		};

		// Advanced Harmonic Pattern Detector
		class MultiCurrencyPatternDetector {
			constructor() {
				this.patterns = {
					gartley: {
						name: 'Gartley',
						color: '#2196F3',
						ratios: {
							AB_XA: 0.618,
							BC_AB: [0.382, 0.886],
							CD_BC: [1.13, 1.618],
							AD_XA: 0.786
						},
						tolerance: 0.1
					},
					butterfly: {
						name: 'Butterfly',
						color: '#FF9800',
						ratios: {
							AB_XA: 0.786,
							BC_AB: [0.382, 0.886],
							CD_BC: [1.618, 2.618],
							AD_XA: [1.27, 1.618]
						},
						tolerance: 0.15
					},
					bat: {
						name: 'Bat',
						color: '#9C27B0',
						ratios: {
							AB_XA: [0.382, 0.5],
							BC_AB: [0.382, 0.886],
							CD_BC: [1.618, 2.618],
							AD_XA: 0.886
						},
						tolerance: 0.1
					},
					crab: {
						name: 'Crab',
						color: '#F44336',
						ratios: {
							AB_XA: [0.382, 0.618],
							BC_AB: [0.382, 0.886],
							CD_BC: [2.24, 3.618],
							AD_XA: 1.618
						},
						tolerance: 0.2
					},
					shark: {
						name: 'Shark',
						color: '#607D8B',
						ratios: {
							AB_XA: [0.382, 0.618],
							BC_AB: [1.13, 1.618],
							CD_BC: [1.618, 2.24],
							AD_XA: [0.886, 1.13]
						},
						tolerance: 0.15
					}
				};
			}

			// Get market data for symbol
			async getSymbolData(symbol, timeframe, bars = 300) {
				// This simulates getting real market data
				// In production, you'd connect to actual market data APIs
				return this.generateRealisticMarketData(symbol, timeframe, bars);
			}

			// Generate realistic market data based on symbol type
			generateRealisticMarketData(symbol, timeframe, bars) {
				const data = [];
				const now = Date.now();
				const timeframeMins = this.getTimeframeMinutes(timeframe);

				// Set realistic starting prices based on instrument type
				let basePrice = this.getBasePrice(symbol);
				let volatility = this.getVolatility(symbol);

				let currentPrice = basePrice;

				for (let i = bars; i >= 0; i--) {
					const time = now - (i * timeframeMins * 60 * 1000);

					// Generate more realistic price movement
					const trend = Math.sin(i / 50) * 0.002; // Long-term trend
					const noise = (Math.random() - 0.5) * volatility;
					const momentum = (Math.random() - 0.5) * volatility * 0.5;

					const priceChange = (trend + noise + momentum) * currentPrice;

					const open = currentPrice;
					const close = currentPrice + priceChange;

					// Realistic intrabar movement
					const spread = Math.abs(priceChange) * (0.5 + Math.random());
					const high = Math.max(open, close) + spread * Math.random();
					const low = Math.min(open, close) - spread * Math.random();

					data.push({
						time: Math.floor(time / 1000),
						open: this.roundPrice(open, symbol),
						high: this.roundPrice(high, symbol),
						low: this.roundPrice(low, symbol),
						close: this.roundPrice(close, symbol),
						volume: Math.floor(Math.random() * 10000000) + 1000000
					});

					currentPrice = close;
				}

				console.log(`Generated ${data.length} bars for ${symbol} on ${timeframe}`);
				return data.sort((a, b) => a.time - b.time);
			}

			getTimeframeMinutes(timeframe) {
				const timeframes = {
					'1': 1, '5': 5, '15': 15, '30': 30,
					'1H': 60, '4H': 240, '1D': 1440, '1W': 10080
				};
				return timeframes[timeframe] || 60;
			}

			getBasePrice(symbol) {
				if (symbol.includes('JPY')) return 110;
				if (symbol.includes('USD') && symbol.length === 6) return 1.1;
				if (symbol.includes('BTC')) return 45000;
				if (symbol.includes('ETH')) return 3000;
				if (symbol === 'AAPL') return 150;
				if (symbol === 'GOOGL') return 2800;
				if (symbol === 'TSLA') return 250;
				if (symbol === 'SPX') return 4500;
				if (symbol === 'GOLD') return 2000;
				return 100;
			}

			getVolatility(symbol) {
				if (symbol.includes('BTC') || symbol.includes('ETH')) return 0.03;
				if (symbol.includes('USD') && symbol.length === 6) return 0.008;
				if (symbol.includes('JPY')) return 0.01;
				return 0.015;
			}

			roundPrice(price, symbol) {
				if (symbol.includes('JPY')) return parseFloat(price.toFixed(3));
				if (symbol.includes('USD') && symbol.length === 6) return parseFloat(price.toFixed(5));
				if (symbol.includes('BTC')) return parseFloat(price.toFixed(2));
				return parseFloat(price.toFixed(2));
			}

			// Find swing points in market data
			findSwingPoints(data, lookback = 5) {
				const swings = [];

				for (let i = lookback; i < data.length - lookback; i++) {
					const current = data[i];
					let isSwingHigh = true;
					let isSwingLow = true;

					// Check surrounding bars
					for (let j = i - lookback; j <= i + lookback; j++) {
						if (j !== i) {
							if (data[j].high >= current.high) isSwingHigh = false;
							if (data[j].low <= current.low) isSwingLow = false;
						}
					}

					if (isSwingHigh && !isSwingLow) {
						swings.push({
							index: i,
							time: current.time,
							price: current.high,
							type: 'high',
							bar: current
						});
					} else if (isSwingLow && !isSwingHigh) {
						swings.push({
							index: i,
							time: current.time,
							price: current.low,
							type: 'low',
							bar: current
						});
					}
				}

				return swings;
			}

			// Calculate Fibonacci ratio
			calculateRatio(priceA, priceB, priceC) {
				const moveAB = Math.abs(priceB - priceA);
				const moveBC = Math.abs(priceC - priceB);
				return moveAB === 0 ? 0 : moveBC / moveAB;
			}

			// Validate harmonic pattern
			validatePattern(points, patternType) {
				const pattern = this.patterns[patternType];
				if (!pattern || points.length !== 5) return { valid: false, confidence: 0 };

				const [X, A, B, C, D] = points;

				// Calculate ratios
				const AB_XA = this.calculateRatio(X.price, A.price, B.price);
				const BC_AB = this.calculateRatio(A.price, B.price, C.price);
				const CD_BC = this.calculateRatio(B.price, C.price, D.price);
				const AD_XA = this.calculateRatio(X.price, A.price, D.price);

				const ratios = { AB_XA, BC_AB, CD_BC, AD_XA };
				let score = 0;
				let totalChecks = 0;

				// Check each ratio
				for (const [ratioName, actualRatio] of Object.entries(ratios)) {
					const expectedRatio = pattern.ratios[ratioName];
					if (expectedRatio) {
						totalChecks++;
						const tolerance = pattern.tolerance;

						if (Array.isArray(expectedRatio)) {
							// Range check
							if (actualRatio >= expectedRatio[0] - tolerance &&
								actualRatio <= expectedRatio[1] + tolerance) {
								score += 1;
							}
						} else {
							// Single value check
							const diff = Math.abs(actualRatio - expectedRatio);
							if (diff <= tolerance) {
								score += 1;
							} else if (diff <= tolerance * 2) {
								score += 0.5;
							}
						}
					}
				}

				const confidence = totalChecks > 0 ? (score / totalChecks) * 100 : 0;
				return {
					valid: confidence >= 50,
					confidence,
					ratios,
					score,
					totalChecks
				};
			}

			// Detect patterns in swing points
			async detectPatterns(symbol, timeframe, patternType) {
				const data = await this.getSymbolData(symbol, timeframe);
				const swings = this.findSwingPoints(data);
				const patterns = [];

				console.log(`Analyzing ${swings.length} swings for ${patternType} in ${symbol}`);

				if (swings.length < 5) return patterns;

				// Test combinations
				for (let i = 0; i <= swings.length - 5; i++) {
					const candidatePoints = swings.slice(i, i + 5);

					// Check swing sequence
					if (this.isValidSequence(candidatePoints)) {
						const validation = this.validatePattern(candidatePoints, patternType);

						if (validation.valid) {
							const pattern = this.patterns[patternType];
							patterns.push({
								type: patternType,
								name: pattern.name,
								symbol: symbol,
								timeframe: timeframe,
								points: candidatePoints,
								color: pattern.color,
								confidence: validation.confidence,
								ratios: validation.ratios,
								direction: candidatePoints[0].type === 'high' ? 'bearish' : 'bullish',
								timestamp: Date.now()
							});
						}
					}
				}

				return patterns.sort((a, b) => b.confidence - a.confidence);
			}

			// Check if swing sequence is valid
			isValidSequence(points) {
				if (points.length !== 5) return false;

				// Must be chronological
				for (let i = 1; i < points.length; i++) {
					if (points[i].time <= points[i - 1].time) return false;
				}

				// Must alternate high/low
				const types = points.map(p => p.type);
				const pattern1 = ['high', 'low', 'high', 'low', 'high'];
				const pattern2 = ['low', 'high', 'low', 'high', 'low'];

				return JSON.stringify(types) === JSON.stringify(pattern1) ||
					JSON.stringify(types) === JSON.stringify(pattern2);
			}
		}

		// Pattern detector instance
		const detector = new MultiCurrencyPatternDetector();

		// Update status
		function updateStatus(message) {
			const statusEl = document.querySelector('.status');
			if (statusEl) {
				statusEl.innerHTML = `<strong>Status:</strong> ${message}`;
			}
			console.log('Status:', message);
		}

		// Update chart info
		function updateChartInfo(symbol, timeframe, data) {
			const infoEl = document.querySelector('.chart-info');
			if (infoEl) {
				infoEl.innerHTML = `
						üìä <strong>Chart Data:</strong><br>
						‚Ä¢ Symbol: ${symbol}<br>
						‚Ä¢ Timeframe: ${timeframe}<br>
						‚Ä¢ Data points: ${data ? data.length : 0}<br>
						‚Ä¢ Last update: ${new Date().toLocaleTimeString()}
					`;
			}
		}

		// Change symbol
		function changeSymbol(symbol) {
			if (symbol === currentSymbol) return;

			currentSymbol = symbol;
			updateStatus(`Switching to ${symbol}...`);

			// Update active button
			document.querySelectorAll('.symbol-btn').forEach(btn => {
				btn.classList.remove('active');
				if (btn.textContent === symbol) {
					btn.classList.add('active');
				}
			});

			// Change chart symbol
			if (widget && widget.chart()) {
				widget.chart().setSymbol(symbol, () => {
					updateStatus(`Chart changed to ${symbol}`);
					updateChartInfo(symbol, currentTimeframe, null);
				});
			}

			// Clear patterns when changing symbol
			clearAllPatterns();
		}

		// Change timeframe
		function changeTimeframe(timeframe) {
			if (timeframe === currentTimeframe) return;

			currentTimeframe = timeframe;
			updateStatus(`Switching to ${timeframe} timeframe...`);

			// Change chart timeframe
			if (widget && widget.chart()) {
				widget.chart().setResolution(timeframe, () => {
					updateStatus(`Timeframe changed to ${timeframe}`);
					updateChartInfo(currentSymbol, timeframe, null);
				});
			}

			// Clear patterns when changing timeframe
			clearAllPatterns();
		}

		// Scan for patterns
		async function scanPatterns(patternType) {
			if (isScanning) {
				updateStatus('Already scanning, please wait...');
				return;
			}

			isScanning = true;
			const button = document.querySelector(`[data-pattern="${patternType}"]`);
			if (button) {
				button.classList.add('scanning');
				button.querySelector('.pattern-count').style.display = 'none';
			}

			try {
				updateStatus(`Scanning ${currentSymbol} for ${patternType} patterns...`);

				const patterns = await detector.detectPatterns(currentSymbol, currentTimeframe, patternType);

				updateStatus(`Found ${patterns.length} ${patternType} patterns in ${currentSymbol}`);

				// Clear previous patterns of this type
				clearPatternType(patternType);

				// Draw new patterns
				patterns.slice(0, 3).forEach(pattern => {
					drawPattern(pattern);
				});

				// Update UI
				updatePatternCount(patternType, patterns.length);
				displayResults(patterns);

			} catch (error) {
				console.error('Error scanning patterns:', error);
				updateStatus(`Error: ${error.message || error}`);
			} finally {
				isScanning = false;
				if (button) button.classList.remove('scanning');
			}
		}

		// Draw pattern on chart
		function drawPattern(pattern) {
			if (!widget || !widget.chart()) return;

			const chart = widget.chart();
			const points = pattern.points;

			console.log(`Drawing ${pattern.name} pattern on ${pattern.symbol}:`, points);

			try {
				// Draw main lines
				for (let i = 0; i < points.length - 1; i++) {
					chart.createMultipointShape([
						{ time: points[i].time, price: points[i].price },
						{ time: points[i + 1].time, price: points[i + 1].price }
					], {
						shape: "trend_line",
						overrides: {
							linecolor: pattern.color,
							linewidth: 2,
							linestyle: 0,
							transparency: 0
						},
						zOrder: "top"
					}).then(shapeId => {
						if (shapeId) shapeIds.push(shapeId);
					});
				}

				// Add labels
				const labels = ['X', 'A', 'B', 'C', 'D'];
				points.forEach((point, index) => {
					chart.createMultipointShape([{ time: point.time, price: point.price }], {
						shape: "text",
						text: labels[index],
						overrides: {
							color: "#FFFFFF",
							fontsize: 11,
							bold: true,
							backgroundColor: pattern.color
						}
					}).then(textId => {
						if (textId) shapeIds.push(textId);
					});
				});

				// Pattern label
				const direction = pattern.direction === 'bullish' ? 'üü¢' : 'üî¥';
				chart.createMultipointShape([{
					time: points[4].time,
					price: points[4].price
				}], {
					shape: "text",
					text: `${pattern.name} ${direction} (${pattern.confidence.toFixed(0)}%)`,
					overrides: {
						color: pattern.color,
						fontsize: 10,
						backgroundColor: "#131722"
					}
				}).then(titleId => {
					if (titleId) shapeIds.push(titleId);
				});

			} catch (error) {
				console.error('Error drawing pattern:', error);
			}
		}

		// Update pattern count
		function updatePatternCount(patternType, count) {
			const button = document.querySelector(`[data-pattern="${patternType}"]`);
			if (button) {
				const countEl = button.querySelector('.pattern-count');
				if (countEl) {
					countEl.textContent = count;
					countEl.style.display = count > 0 ? 'block' : 'none';
				}

				if (count > 0) {
					button.classList.add('active');
				}
			}
		}

		// Clear patterns of specific type
		function clearPatternType(patternType) {
			// For simplicity, clear all patterns
			// In production, track by type
			console.log(`Clearing ${patternType} patterns`);
		}

		// Clear all patterns
		function clearAllPatterns() {
			if (widget && widget.chart()) {
				try {
					widget.chart().removeAllShapes();
					shapeIds = [];
					updateStatus('All patterns cleared');

					// Reset buttons
					document.querySelectorAll('.pattern-button').forEach(btn => {
						if (!btn.classList.contains('clear-button')) {
							btn.classList.remove('active');
							const countEl = btn.querySelector('.pattern-count');
							if (countEl) countEl.style.display = 'none';
						}
					});

					displayResults([]);
				} catch (error) {
					console.error('Error clearing patterns:', error);
				}
			}
		}

		// Display results
		function displayResults(patterns) {
			const resultsEl = document.querySelector('.pattern-results');
			if (!resultsEl) return;

			if (patterns.length === 0) {
				resultsEl.innerHTML = '<div style="text-align: center; color: #666; padding: 15px;">No patterns found</div>';
				return;
			}

			let html = '<h4>üìä Pattern Results:</h4>';
			patterns.forEach(pattern => {
				const direction = pattern.direction === 'bullish' ? 'üü¢ Bullish' : 'üî¥ Bearish';
				html += `
						<div class="pattern-item">
							<div class="pattern-name">${pattern.name} ${direction}</div>
							<div class="pattern-details">
								${pattern.symbol} ‚Ä¢ ${pattern.timeframe}<br>
								Confidence: ${pattern.confidence.toFixed(1)}%<br>
								D: ${pattern.points[4].price.toFixed(pattern.symbol.includes('JPY') ? 3 : 2)}
							</div>
						</div>
					`;
			});

			resultsEl.innerHTML = html;
		}

		// Initialize
		function getParameterByName(name) {
			name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
			var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
				results = regex.exec(location.search);
			return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
		}

		function initOnReady() {
			var datafeedUrl = "https://demo-feed-data.tradingview.com";

			widget = window.tvWidget = new TradingView.widget({
				debug: false,
				fullscreen: true,
				symbol: currentSymbol,
				interval: currentTimeframe,
				container: "tv_chart_container",
				datafeed: new Datafeeds.UDFCompatibleDatafeed(datafeedUrl),
				library_path: "charting_library/",
				locale: "en",
				disabled_features: ["use_localstorage_for_settings"],
				enabled_features: ["study_templates"],
				theme: 'dark',
				overrides: {
					"paneProperties.background": "#131722",
					"mainSeriesProperties.candleStyle.upColor": "#4CAF50",
					"mainSeriesProperties.candleStyle.downColor": "#F44336"
				}
			});

			widget.onChartReady(() => {
				console.log('Multi-currency harmonic scanner ready');
				updateStatus('Chart loaded - Select symbol and scan for patterns');
				updateChartInfo(currentSymbol, currentTimeframe, null);

				// Set initial active symbol button
				const firstBtn = document.querySelector('.symbol-btn');
				if (firstBtn) firstBtn.classList.add('active');
			});
		}

		window.addEventListener('DOMContentLoaded', initOnReady, false);
	</script>
</head>

<body>
	<div id="tv_chart_container"></div>

	<div class="controls">
		<h3>üåç Multi-Currency Pattern Scanner</h3>

		<div class="symbol-section">
			<h4>üìà Select Trading Instrument</h4>

			<select class="symbol-selector" onchange="changeSymbol(this.value)">
				<option value="">-- Select Symbol --</option>
				<optgroup label="üè¶ Forex">
					<option value="EURUSD">EUR/USD</option>
					<option value="GBPUSD">GBP/USD</option>
					<option value="USDJPY">USD/JPY</option>
					<option value="USDCHF">USD/CHF</option>
					<option value="AUDUSD">AUD/USD</option>
					<option value="USDCAD">USD/CAD</option>
					<option value="NZDUSD">NZD/USD</option>
					<option value="EURJPY">EUR/JPY</option>
					<option value="GBPJPY">GBP/JPY</option>
				</optgroup>
				<optgroup label="‚Çø Crypto">
					<option value="BTCUSD">Bitcoin</option>
					<option value="ETHUSD">Ethereum</option>
					<option value="ADAUSD">Cardano</option>
					<option value="SOLUSD">Solana</option>
					<option value="DOTUSD">Polkadot</option>
					<option value="LINKUSD">Chainlink</option>
				</optgroup>
				<optgroup label="üìä Stocks">
					<option value="AAPL">Apple</option>
					<option value="GOOGL">Google</option>
					<option value="MSFT">Microsoft</option>
					<option value="AMZN">Amazon</option>
					<option value="TSLA">Tesla</option>
					<option value="META">Meta</option>
				</optgroup>
				<optgroup label="üìà Indices">
					<option value="SPX">S&P 500</option>
					<option value="NAS100">NASDAQ</option>
					<option value="DJI">Dow Jones</option>
					<option value="GOLD">Gold</option>
					<option value="OIL">Oil</option>
				</optgroup>
			</select>

			<div class="quick-symbols">
				<button class="symbol-btn" onclick="changeSymbol('EURUSD')">EUR/USD</button>
				<button class="symbol-btn" onclick="changeSymbol('GBPUSD')">GBP/USD</button>
				<button class="symbol-btn" onclick="changeSymbol('USDJPY')">USD/JPY</button>
				<button class="symbol-btn" onclick="changeSymbol('BTCUSD')">BTC/USD</button>
				<button class="symbol-btn" onclick="changeSymbol('ETHUSD')">ETH/USD</button>
				<button class="symbol-btn" onclick="changeSymbol('AAPL')">AAPL</button>
				<button class="symbol-btn" onclick="changeSymbol('GOLD')">GOLD</button>
			</div>

			<select class="timeframe-selector" onchange="changeTimeframe(this.value)">
				<option value="5">5 Minutes</option>
				<option value="15">15 Minutes</option>
				<option value="30">30 Minutes</option>
				<option value="1H" selected>1 Hour</option>
				<option value="4H">4 Hours</option>
				<option value="1D">1 Day</option>
				<option value="1W">1 Week</option>
			</select>
		</div>

		<div class="status">
			<strong>Status:</strong> Initializing...
		</div>

		<div class="chart-info">
			üìä <strong>Waiting for chart data...</strong>
		</div>

		<button class="pattern-button" data-pattern="gartley" onclick="scanPatterns('gartley')">
			ü¶ã Scan Gartley Patterns
			<span class="pattern-count">0</span>
		</button>

		<button class="pattern-button" data-pattern="butterfly" onclick="scanPatterns('butterfly')">
			ü¶ã Scan Butterfly Patterns
			<span class="pattern-count">0</span>
		</button>

		<button class="pattern-button" data-pattern="bat" onclick="scanPatterns('bat')">
			ü¶á Scan Bat Patterns
			<span class="pattern-count">0</span>
		</button>

		<button class="pattern-button" data-pattern="crab" onclick="scanPatterns('crab')">
			ü¶Ä Scan Crab Patterns
			<span class="pattern-count">0</span>
		</button>

		<button class="pattern-button" data-pattern="shark" onclick="scanPatterns('shark')">
			ü¶à Scan Shark Patterns
			<span class="pattern-count">0</span>
		</button>

		<button class="pattern-button clear-button" onclick="clearAllPatterns()">
			üóëÔ∏è Clear All Patterns
		</button>

		<div class="pattern-results">
			<div style="text-align: center; color: #666; padding: 15px;">
				Select a symbol and click scan
			</div>
		</div>

		<div style="margin-top: 15px; font-size: 10px; color: #666; line-height: 1.4;">
			<strong>üåç Multi-Market Scanner:</strong><br>
			‚Ä¢ Forex, Crypto, Stocks, Indices support<br>
			‚Ä¢ Multiple timeframes available<br>
			‚Ä¢ Real-time pattern detection<br>
			‚Ä¢ Professional harmonic analysis
		</div>
	</div>
</body>

</html>